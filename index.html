<script>
/** CONFIG **/
const DATA_URL = 'spells-data.json';
const EDIT_DATA_URL =
  'https://github.com/YOURUSER/YOURREPO/edit/main/spells-data.json';
document.getElementById('editLink').href = EDIT_DATA_URL;

/** DOM helpers **/
const $ = (s) => document.querySelector(s);
const sideTabs = document.querySelector('.tabs');
const listEl = $('#list');
const subjectTitle = $('#subjectTitle');
const sideEl = document.querySelector('.side');

/** State & data **/
let SUBJECTS = []; // { key, name, count }
let SPELLS = [];
const state = { q: '', dif: '', year: '', subject: '', oc: false };

/** Utility: convert 'charmwork_enchantment' to 'Charmwork Enchantment' */
function toLabel(key) {
  return key
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/** Build sidebar buttons with counts */
function buildTabs() {
  sideTabs.innerHTML = '';
  SUBJECTS.forEach(({ key, name, count }) => {
    const btn = document.createElement('button');
    btn.textContent = `${name} (${count})`;
    btn.setAttribute('aria-current', String(state.subject === key));
    btn.addEventListener('click', () => {
      state.subject = key;
      render();
    });
    sideTabs.appendChild(btn);
  });
}

/** Determine if a spell is allowed for the current year filter */
function allowedByYear(dif) {
  if (!state.year) return true;
  switch (state.year) {
    case 'y12':
      return dif === 'Beginner';
    case 'y34':
      return ['Beginner', 'Intermediate'].includes(dif);
    case 'y57':
      return ['Beginner', 'Intermediate', 'Advanced'].includes(dif);
    case 'post':
      return true;
    default:
      return true;
  }
}

/** Filter logic for search, difficulty, year, and OC toggle */
function matches(sp) {
  if (state.dif && sp.difficulty !== state.dif) return false;
  if (!allowedByYear(sp.difficulty)) return false;
  if (!state.oc && sp.oc) return false;
  if (state.q) {
    const blob = [
      sp.name,
      sp.effect,
      sp.creator,
      sp.pron,
      sp.wand,
      sp.notes,
      sp.subject,
    ]
      .filter(Boolean)
      .join(' ')
      .toLowerCase();
    if (!blob.includes(state.q)) return false;
  }
  return true;
}

/** Render a single spell row */
function makeRow(sp) {
  const it = document.createElement('details');
  it.className = 'item';
  const sum = document.createElement('summary');

  const nameWrap = document.createElement('div');
  nameWrap.className = 'namewrap';
  const name = document.createElement('div');
  name.className = 'name';
  name.textContent = sp.name;
  const preview = document.createElement('div');
  preview.className = 'effect-preview';
  preview.textContent = sp.effect || '—';
  nameWrap.append(name, preview);

  const meta = document.createElement('div');
  meta.className = 'meta';
  const pill1 = document.createElement('span');
  pill1.className = 'pill';
  pill1.textContent = sp.difficulty || '—';
  meta.appendChild(pill1);
  const pill2 = document.createElement('span');
  pill2.className = 'pill';
  pill2.textContent = sp.creator || '—';
  meta.appendChild(pill2);
  if (sp.oc) {
    const oc = document.createElement('span');
    oc.className = 'pill';
    oc.textContent = 'OC';
    meta.appendChild(oc);
  }

  sum.append(nameWrap, meta);

  const body = document.createElement('div');
  body.className = 'body';
  const specs = document.createElement('div');
  specs.className = 'spec grid-2';
  specs.innerHTML = `
    <dl>
      <dt>Pronunciation</dt><dd>${sp.pron || '—'}</dd>
      <dt>Wand movement</dt><dd>${sp.wand || '—'}</dd>
    </dl>
    <dl>
      <dt>Effect</dt><dd>${sp.effect || '—'}</dd>
      <dt>Notes</dt><dd class="notes">${sp.notes || ''}</dd>
    </dl>`;
  body.appendChild(specs);
  it.append(sum, body);
  return it;
}

/** Render the list based on current state */
function render() {
  // Update tab highlighting
  SUBJECTS.forEach(({ key }, idx) => {
    const btn = sideTabs.children[idx];
    btn.setAttribute('aria-current', String(key === state.subject));
  });

  // Update subject title
  const active = SUBJECTS.find((s) => s.key === state.subject);
  subjectTitle.textContent = active ? active.name : 'Spells';

  // Filter and sort spells
  const items = SPELLS
    .filter((s) => s.subject === state.subject)
    .filter(matches)
    .sort((a, b) => a.name.localeCompare(b.name));

  listEl.innerHTML = '';
  if (!items.length) {
    const d = document.createElement('div');
    d.className = 'empty';
    d.innerHTML = 'No entries. Edit <code>spells-data.json</code> or loosen filters.';
    listEl.appendChild(d);
    return;
  }
  items.forEach((sp) => listEl.appendChild(makeRow(sp)));
}

/** Event listeners for search/filters/toggles */
$('#q').addEventListener('input', (e) => {
  state.q = e.target.value.trim().toLowerCase();
  render();
});
$('#dif').addEventListener('change', (e) => {
  state.dif = e.target.value;
  render();
});
$('#year').addEventListener('change', (e) => {
  state.year = e.target.value;
  render();
});
$('#modeCanon').addEventListener('click', () => {
  state.oc = false;
  $('#modeCanon').setAttribute('aria-pressed', 'true');
  $('#modeAll').setAttribute('aria-pressed', 'false');
  render();
});
$('#modeAll').addEventListener('click', () => {
  state.oc = true;
  $('#modeAll').setAttribute('aria-pressed', 'true');
  $('#modeCanon').setAttribute('aria-pressed', 'false');
  render();
});

/** Sticky aside handler */
function updateSticky() {
  const fits = window.innerWidth >= 981 && (sideEl.scrollHeight + 24) <= window.innerHeight;
  sideEl.classList.toggle('is-sticky', fits);
}

/** JSON loader: fetch and transform your spells-data.json */
async function boot() {
  try {
    const res = await fetch(DATA_URL, { cache: 'no-store' });
    if (!res.ok) throw new Error('HTTP ' + res.status);

    // Read raw and strip BOM/comments/trailing commas
    let raw = await res.text();
    raw = raw
      .replace(/\uFEFF/g, '')
      .replace(/\/\*[\s\S]*?\*\//g, '')
      .replace(/(^|[^:])\/\/.*$/gm, '$1')
      .replace(/,\s*(\}|\])/g, '$1');
    const data = JSON.parse(raw);

    const categories = [];
    const spells = [];

    // Your JSON is keyed by category (e.g. transfiguration, charmwork_enchantment)
    Object.keys(data).forEach((key) => {
      const list = Array.isArray(data[key]) ? data[key] : [];
      categories.push({ key, name: toLabel(key), count: list.length });
      list.forEach((s) => {
        // Derive difficulty from caster_level
        let difficulty = 'Beginner';
        const level = s.caster_level || '';
        if (/Intermediate/i.test(level)) difficulty = 'Intermediate';
        else if (/Advanced/i.test(level)) difficulty = 'Advanced';
        else if (/Expert|Dark/i.test(level)) difficulty = 'Expert';
        spells.push({
          subject: key,
          oc: !!s.oc,
          name: s.name,
          difficulty,
          creator: s.inventor_and_year || 'Unknown',
          pron: s.pronunciation,
          wand: s.wand_movements,
          effect: s.effect,
          notes: s.notes,
        });
      });
    });

    SUBJECTS = categories;
    SPELLS = spells;
    state.subject = SUBJECTS.length ? SUBJECTS[0].key : '';
    buildTabs();
    render();
    updateSticky();
    window.addEventListener('resize', updateSticky);
  } catch (err) {
    listEl.innerHTML = `<div class="empty">
      Could not load <code>${DATA_URL}</code>. Ensure it exists at the repo root and the JSON is valid.
      <br><small>${String(err)}</small>
    </div>`;
  }
}

boot();
</script>
